/* tslint:disable */
/* eslint-disable */
/**
 * AI Dungeon Master API
 * Backend API for the AI Dungeon Master application
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AIAssistanceRequest
 */
export interface AIAssistanceRequest {
    /**
     * 
     * @type {string}
     * @memberof AIAssistanceRequest
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof AIAssistanceRequest
     */
    'context_type': string;
    /**
     * 
     * @type {string}
     * @memberof AIAssistanceRequest
     */
    'campaign_tone'?: string | null;
}
/**
 * 
 * @export
 * @interface AIAssistanceResponse
 */
export interface AIAssistanceResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof AIAssistanceResponse
     */
    'suggestions': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AIAssistanceResponse
     */
    'enhanced_text'?: string | null;
}
/**
 * 
 * @export
 * @interface AIContentGenerationRequest
 */
export interface AIContentGenerationRequest {
    /**
     * 
     * @type {string}
     * @memberof AIContentGenerationRequest
     */
    'suggestion': string;
    /**
     * 
     * @type {string}
     * @memberof AIContentGenerationRequest
     */
    'current_text': string;
    /**
     * 
     * @type {string}
     * @memberof AIContentGenerationRequest
     */
    'context_type': string;
    /**
     * 
     * @type {string}
     * @memberof AIContentGenerationRequest
     */
    'campaign_tone'?: string | null;
}
/**
 * 
 * @export
 * @interface AIContentGenerationResponse
 */
export interface AIContentGenerationResponse {
    /**
     * 
     * @type {string}
     * @memberof AIContentGenerationResponse
     */
    'generated_content': string;
    /**
     * 
     * @type {boolean}
     * @memberof AIContentGenerationResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof AIContentGenerationResponse
     */
    'error'?: string | null;
}
/**
 * 
 * @export
 * @interface Abilities
 */
export interface Abilities {
    /**
     * 
     * @type {number}
     * @memberof Abilities
     */
    'strength'?: number;
    /**
     * 
     * @type {number}
     * @memberof Abilities
     */
    'dexterity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Abilities
     */
    'constitution'?: number;
    /**
     * 
     * @type {number}
     * @memberof Abilities
     */
    'intelligence'?: number;
    /**
     * 
     * @type {number}
     * @memberof Abilities
     */
    'wisdom'?: number;
    /**
     * 
     * @type {number}
     * @memberof Abilities
     */
    'charisma'?: number;
}
/**
 * 
 * @export
 * @interface Campaign
 */
export interface Campaign {
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'setting': string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'dm_notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'created_at'?: string;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof Campaign
     */
    'characters'?: Array<string | null>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Campaign
     */
    'locations'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Campaign
     */
    'npcs'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Campaign
     */
    'quests'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'current_location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'tone'?: string;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof Campaign
     */
    'homebrew_rules'?: Array<string | null>;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof Campaign
     */
    'session_log'?: Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'world_description'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Campaign
     */
    'world_art'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {boolean}
     * @memberof Campaign
     */
    'is_template'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Campaign
     */
    'is_custom'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'template_id'?: string | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof Campaign
     */
    'plot_hooks'?: Array<string | null>;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof Campaign
     */
    'key_npcs'?: Array<string | null>;
}
/**
 * 
 * @export
 * @interface CampaignListResponse
 */
export interface CampaignListResponse {
    /**
     * 
     * @type {Array<Campaign>}
     * @memberof CampaignListResponse
     */
    'campaigns': Array<Campaign>;
    /**
     * 
     * @type {Array<Campaign>}
     * @memberof CampaignListResponse
     */
    'templates': Array<Campaign>;
}
/**
 * 
 * @export
 * @interface CampaignUpdateRequest
 */
export interface CampaignUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CampaignUpdateRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CampaignUpdateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CampaignUpdateRequest
     */
    'setting'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CampaignUpdateRequest
     */
    'tone'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CampaignUpdateRequest
     */
    'homebrew_rules'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof CampaignUpdateRequest
     */
    'world_description'?: string | null;
}
/**
 * 
 * @export
 * @interface CastSpellRequest
 */
export interface CastSpellRequest {
    /**
     * 
     * @type {string}
     * @memberof CastSpellRequest
     */
    'combat_id': string;
    /**
     * 
     * @type {string}
     * @memberof CastSpellRequest
     */
    'character_id': string;
    /**
     * 
     * @type {string}
     * @memberof CastSpellRequest
     */
    'spell_id': string;
    /**
     * 
     * @type {number}
     * @memberof CastSpellRequest
     */
    'slot_level': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CastSpellRequest
     */
    'target_ids'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof CastSpellRequest
     */
    'spell_attack_roll'?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CharacterClass = {
    Fighter: 'fighter',
    Wizard: 'wizard',
    Rogue: 'rogue',
    Cleric: 'cleric',
    Bard: 'bard',
    Druid: 'druid',
    Warlock: 'warlock',
    Monk: 'monk',
    Paladin: 'paladin',
    Ranger: 'ranger',
    Sorcerer: 'sorcerer',
    Barbarian: 'barbarian'
} as const;

export type CharacterClass = typeof CharacterClass[keyof typeof CharacterClass];


/**
 * 
 * @export
 * @interface CharacterSheet
 */
export interface CharacterSheet {
    /**
     * 
     * @type {string}
     * @memberof CharacterSheet
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CharacterSheet
     */
    'name': string;
    /**
     * 
     * @type {Race}
     * @memberof CharacterSheet
     */
    'race': Race;
    /**
     * 
     * @type {CharacterClass}
     * @memberof CharacterSheet
     */
    'character_class': CharacterClass | null;
    /**
     * 
     * @type {number}
     * @memberof CharacterSheet
     */
    'level'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterSheet
     */
    'background'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CharacterSheet
     */
    'alignment'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CharacterSheet
     */
    'experience'?: number;
    /**
     * 
     * @type {Abilities}
     * @memberof CharacterSheet
     */
    'abilities': Abilities;
    /**
     * 
     * @type {HitPoints}
     * @memberof CharacterSheet
     */
    'hit_points': HitPoints;
    /**
     * 
     * @type {number}
     * @memberof CharacterSheet
     */
    'armor_class'?: number;
    /**
     * 
     * @type {number}
     * @memberof CharacterSheet
     */
    'speed'?: number;
    /**
     * 
     * @type {number}
     * @memberof CharacterSheet
     */
    'proficiency_bonus'?: number;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof CharacterSheet
     */
    'skills'?: { [key: string]: boolean; };
    /**
     * 
     * @type {Array<InventorySlot>}
     * @memberof CharacterSheet
     */
    'inventory'?: Array<InventorySlot>;
    /**
     * 
     * @type {Array<EquippedItem>}
     * @memberof CharacterSheet
     */
    'equipped_items'?: Array<EquippedItem>;
    /**
     * 
     * @type {number}
     * @memberof CharacterSheet
     */
    'carrying_capacity'?: number | null;
    /**
     * 
     * @type {Array<Spell>}
     * @memberof CharacterSheet
     */
    'spells'?: Array<Spell>;
    /**
     * 
     * @type {SpellCasting}
     * @memberof CharacterSheet
     */
    'spellcasting'?: SpellCasting | null;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof CharacterSheet
     */
    'features'?: Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {string}
     * @memberof CharacterSheet
     */
    'backstory'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CharacterSheet
     */
    'ability_score_improvements_used'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterSheet
     */
    'hit_dice'?: string;
}


/**
 * 
 * @export
 * @interface CloneCampaignRequest
 */
export interface CloneCampaignRequest {
    /**
     * 
     * @type {string}
     * @memberof CloneCampaignRequest
     */
    'template_id': string;
    /**
     * 
     * @type {string}
     * @memberof CloneCampaignRequest
     */
    'new_name'?: string | null;
}
/**
 * 
 * @export
 * @interface ConcentrationCheckResponse
 */
export interface ConcentrationCheckResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ConcentrationCheckResponse
     */
    'success': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConcentrationCheckResponse
     */
    'concentration_maintained': boolean;
    /**
     * 
     * @type {number}
     * @memberof ConcentrationCheckResponse
     */
    'dc': number;
    /**
     * 
     * @type {number}
     * @memberof ConcentrationCheckResponse
     */
    'roll_result'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ConcentrationCheckResponse
     */
    'spell_ended'?: boolean;
}
/**
 * 
 * @export
 * @interface ConcentrationRequest
 */
export interface ConcentrationRequest {
    /**
     * 
     * @type {string}
     * @memberof ConcentrationRequest
     */
    'character_id': string;
    /**
     * 
     * @type {string}
     * @memberof ConcentrationRequest
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof ConcentrationRequest
     */
    'spell_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ConcentrationRequest
     */
    'damage_taken'?: number | null;
}
/**
 * 
 * @export
 * @interface CreateCampaignRequest
 */
export interface CreateCampaignRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'setting': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'tone'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCampaignRequest
     */
    'homebrew_rules'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateCharacterRequest
 */
export interface CreateCharacterRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCharacterRequest
     */
    'name': string;
    /**
     * 
     * @type {Race}
     * @memberof CreateCharacterRequest
     */
    'race': Race;
    /**
     * 
     * @type {CharacterClass}
     * @memberof CreateCharacterRequest
     */
    'character_class': CharacterClass;
    /**
     * 
     * @type {Abilities}
     * @memberof CreateCharacterRequest
     */
    'abilities': Abilities;
    /**
     * 
     * @type {string}
     * @memberof CreateCharacterRequest
     */
    'backstory'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateCharacterRequest
     */
    'background'?: string | null;
}


/**
 * 
 * @export
 * @interface CreateNPCRequest
 */
export interface CreateNPCRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateNPCRequest
     */
    'campaign_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNPCRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNPCRequest
     */
    'race'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateNPCRequest
     */
    'gender'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreateNPCRequest
     */
    'age'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateNPCRequest
     */
    'occupation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateNPCRequest
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateNPCRequest
     */
    'importance'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateNPCRequest
     */
    'story_role'?: string | null;
}
/**
 * 
 * @export
 * @interface EncumbranceResponse
 */
export interface EncumbranceResponse {
    /**
     * 
     * @type {string}
     * @memberof EncumbranceResponse
     */
    'character_id': string;
    /**
     * 
     * @type {number}
     * @memberof EncumbranceResponse
     */
    'current_weight': number;
    /**
     * 
     * @type {number}
     * @memberof EncumbranceResponse
     */
    'carrying_capacity': number;
    /**
     * 
     * @type {string}
     * @memberof EncumbranceResponse
     */
    'encumbrance_level': string;
    /**
     * 
     * @type {number}
     * @memberof EncumbranceResponse
     */
    'speed_penalty'?: number;
}
/**
 * 
 * @export
 * @interface Equipment
 */
export interface Equipment {
    /**
     * 
     * @type {string}
     * @memberof Equipment
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Equipment
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Equipment
     */
    'description'?: string | null;
    /**
     * 
     * @type {ItemType}
     * @memberof Equipment
     */
    'item_type': ItemType;
    /**
     * 
     * @type {ItemRarity}
     * @memberof Equipment
     */
    'rarity'?: ItemRarity;
    /**
     * 
     * @type {number}
     * @memberof Equipment
     */
    'weight'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Equipment
     */
    'value'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Equipment
     */
    'requires_attunement'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Equipment
     */
    'is_magical'?: boolean;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof Equipment
     */
    'stat_modifiers'?: { [key: string]: number; };
    /**
     * 
     * @type {Array<string>}
     * @memberof Equipment
     */
    'special_abilities'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Equipment
     */
    'damage_dice'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Equipment
     */
    'damage_type'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Equipment
     */
    'armor_class'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Equipment
     */
    'properties'?: Array<string>;
}


/**
 * 
 * @export
 * @interface EquipmentResponse
 */
export interface EquipmentResponse {
    /**
     * 
     * @type {boolean}
     * @memberof EquipmentResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof EquipmentResponse
     */
    'message': string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof EquipmentResponse
     */
    'stat_changes'?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof EquipmentResponse
     */
    'armor_class_change'?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EquipmentSlot = {
    MainHand: 'main_hand',
    OffHand: 'off_hand',
    TwoHands: 'two_hands',
    Head: 'head',
    Chest: 'chest',
    Legs: 'legs',
    Feet: 'feet',
    Hands: 'hands',
    Ring1: 'ring_1',
    Ring2: 'ring_2',
    Neck: 'neck',
    Cloak: 'cloak'
} as const;

export type EquipmentSlot = typeof EquipmentSlot[keyof typeof EquipmentSlot];


/**
 * 
 * @export
 * @interface EquippedItem
 */
export interface EquippedItem {
    /**
     * 
     * @type {string}
     * @memberof EquippedItem
     */
    'equipment_id': string;
    /**
     * 
     * @type {EquipmentSlot}
     * @memberof EquippedItem
     */
    'slot': EquipmentSlot;
    /**
     * 
     * @type {boolean}
     * @memberof EquippedItem
     */
    'attuned'?: boolean;
}


/**
 * 
 * @export
 * @interface GameResponse
 */
export interface GameResponse {
    /**
     * 
     * @type {string}
     * @memberof GameResponse
     */
    'message': string;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof GameResponse
     */
    'images'?: Array<string | null>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof GameResponse
     */
    'state_updates'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof GameResponse
     */
    'combat_updates'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface GenerateNPCStatsRequest
 */
export interface GenerateNPCStatsRequest {
    /**
     * 
     * @type {string}
     * @memberof GenerateNPCStatsRequest
     */
    'npc_id': string;
    /**
     * 
     * @type {number}
     * @memberof GenerateNPCStatsRequest
     */
    'level'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GenerateNPCStatsRequest
     */
    'role'?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface HitPoints
 */
export interface HitPoints {
    /**
     * 
     * @type {number}
     * @memberof HitPoints
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof HitPoints
     */
    'maximum': number;
}
/**
 * 
 * @export
 * @interface InventorySlot
 */
export interface InventorySlot {
    /**
     * 
     * @type {string}
     * @memberof InventorySlot
     */
    'item_id': string;
    /**
     * 
     * @type {number}
     * @memberof InventorySlot
     */
    'quantity': number;
    /**
     * 
     * @type {Array<EquipmentSlot>}
     * @memberof InventorySlot
     */
    'equipped_slots'?: Array<EquipmentSlot>;
}
/**
 * 
 * @export
 * @interface ItemCatalogResponse
 */
export interface ItemCatalogResponse {
    /**
     * 
     * @type {Array<Equipment>}
     * @memberof ItemCatalogResponse
     */
    'items': Array<Equipment>;
    /**
     * 
     * @type {number}
     * @memberof ItemCatalogResponse
     */
    'total_count': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ItemRarity = {
    Common: 'common',
    Uncommon: 'uncommon',
    Rare: 'rare',
    VeryRare: 'very_rare',
    Legendary: 'legendary',
    Artifact: 'artifact'
} as const;

export type ItemRarity = typeof ItemRarity[keyof typeof ItemRarity];


/**
 * 
 * @export
 * @enum {string}
 */

export const ItemType = {
    Weapon: 'weapon',
    Armor: 'armor',
    Shield: 'shield',
    Tool: 'tool',
    Consumable: 'consumable',
    Treasure: 'treasure',
    Ring: 'ring',
    Amulet: 'amulet',
    Wondrous: 'wondrous'
} as const;

export type ItemType = typeof ItemType[keyof typeof ItemType];


/**
 * 
 * @export
 * @interface LevelUpRequest
 */
export interface LevelUpRequest {
    /**
     * 
     * @type {string}
     * @memberof LevelUpRequest
     */
    'character_id': string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof LevelUpRequest
     */
    'ability_improvements'?: { [key: string]: number; } | null;
    /**
     * 
     * @type {string}
     * @memberof LevelUpRequest
     */
    'feat_choice'?: string | null;
}
/**
 * 
 * @export
 * @interface MagicalEffectsRequest
 */
export interface MagicalEffectsRequest {
    /**
     * 
     * @type {string}
     * @memberof MagicalEffectsRequest
     */
    'character_id': string;
    /**
     * 
     * @type {string}
     * @memberof MagicalEffectsRequest
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof MagicalEffectsRequest
     */
    'action': string;
}
/**
 * 
 * @export
 * @interface MagicalEffectsResponse
 */
export interface MagicalEffectsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof MagicalEffectsResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof MagicalEffectsResponse
     */
    'message': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MagicalEffectsResponse
     */
    'active_effects': Array<string>;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof MagicalEffectsResponse
     */
    'stat_modifiers': { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface ManageEquipmentRequest
 */
export interface ManageEquipmentRequest {
    /**
     * 
     * @type {string}
     * @memberof ManageEquipmentRequest
     */
    'character_id': string;
    /**
     * 
     * @type {string}
     * @memberof ManageEquipmentRequest
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof ManageEquipmentRequest
     */
    'equipment_id': string;
    /**
     * 
     * @type {EquipmentSlot}
     * @memberof ManageEquipmentRequest
     */
    'slot'?: EquipmentSlot | null;
}


/**
 * 
 * @export
 * @interface ManageSpellSlotsRequest
 */
export interface ManageSpellSlotsRequest {
    /**
     * 
     * @type {string}
     * @memberof ManageSpellSlotsRequest
     */
    'character_id': string;
    /**
     * 
     * @type {string}
     * @memberof ManageSpellSlotsRequest
     */
    'action': string;
    /**
     * 
     * @type {number}
     * @memberof ManageSpellSlotsRequest
     */
    'slot_level': number;
    /**
     * 
     * @type {number}
     * @memberof ManageSpellSlotsRequest
     */
    'count'?: number | null;
}
/**
 * 
 * @export
 * @interface ManageSpellsRequest
 */
export interface ManageSpellsRequest {
    /**
     * 
     * @type {string}
     * @memberof ManageSpellsRequest
     */
    'character_id': string;
    /**
     * 
     * @type {string}
     * @memberof ManageSpellsRequest
     */
    'action': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ManageSpellsRequest
     */
    'spell_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface NPC
 */
export interface NPC {
    /**
     * 
     * @type {string}
     * @memberof NPC
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof NPC
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NPC
     */
    'race'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NPC
     */
    'gender'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof NPC
     */
    'age'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof NPC
     */
    'occupation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NPC
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NPC
     */
    'campaign_id': string;
    /**
     * 
     * @type {NPCPersonality}
     * @memberof NPC
     */
    'personality'?: NPCPersonality;
    /**
     * 
     * @type {string}
     * @memberof NPC
     */
    'voice_description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof NPC
     */
    'level'?: number;
    /**
     * 
     * @type {Abilities}
     * @memberof NPC
     */
    'abilities'?: Abilities | null;
    /**
     * 
     * @type {HitPoints}
     * @memberof NPC
     */
    'hit_points'?: HitPoints | null;
    /**
     * 
     * @type {number}
     * @memberof NPC
     */
    'armor_class'?: number | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof NPC
     */
    'skills'?: { [key: string]: number; };
    /**
     * 
     * @type {Array<NPCRelationship>}
     * @memberof NPC
     */
    'relationships'?: Array<NPCRelationship>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NPC
     */
    'interaction_history'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NPC
     */
    'importance'?: string;
    /**
     * 
     * @type {string}
     * @memberof NPC
     */
    'story_role'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof NPC
     */
    'quest_involvement'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof NPC
     */
    'is_alive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NPC
     */
    'current_mood'?: string;
    /**
     * 
     * @type {string}
     * @memberof NPC
     */
    'notes'?: string | null;
}
/**
 * 
 * @export
 * @interface NPCInteractionRequest
 */
export interface NPCInteractionRequest {
    /**
     * 
     * @type {string}
     * @memberof NPCInteractionRequest
     */
    'npc_id': string;
    /**
     * 
     * @type {string}
     * @memberof NPCInteractionRequest
     */
    'character_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NPCInteractionRequest
     */
    'interaction_type': string;
    /**
     * 
     * @type {string}
     * @memberof NPCInteractionRequest
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof NPCInteractionRequest
     */
    'outcome'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof NPCInteractionRequest
     */
    'relationship_change'?: number;
}
/**
 * 
 * @export
 * @interface NPCInteractionResponse
 */
export interface NPCInteractionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof NPCInteractionResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof NPCInteractionResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof NPCInteractionResponse
     */
    'interaction_id': string;
    /**
     * 
     * @type {number}
     * @memberof NPCInteractionResponse
     */
    'new_relationship_level'?: number | null;
}
/**
 * 
 * @export
 * @interface NPCPersonality
 */
export interface NPCPersonality {
    /**
     * 
     * @type {Array<string>}
     * @memberof NPCPersonality
     */
    'traits'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NPCPersonality
     */
    'ideals'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NPCPersonality
     */
    'bonds'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NPCPersonality
     */
    'flaws'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NPCPersonality
     */
    'mannerisms'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NPCPersonality
     */
    'appearance'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof NPCPersonality
     */
    'motivations'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NPCRelationship
 */
export interface NPCRelationship {
    /**
     * 
     * @type {string}
     * @memberof NPCRelationship
     */
    'character_id': string;
    /**
     * 
     * @type {string}
     * @memberof NPCRelationship
     */
    'relationship_type': string;
    /**
     * 
     * @type {number}
     * @memberof NPCRelationship
     */
    'trust_level'?: number;
    /**
     * 
     * @type {string}
     * @memberof NPCRelationship
     */
    'notes'?: string | null;
}
/**
 * 
 * @export
 * @interface NPCStatsResponse
 */
export interface NPCStatsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof NPCStatsResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof NPCStatsResponse
     */
    'message': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NPCStatsResponse
     */
    'generated_stats': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface PlayerInput
 */
export interface PlayerInput {
    /**
     * 
     * @type {string}
     * @memberof PlayerInput
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerInput
     */
    'character_id': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerInput
     */
    'campaign_id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Race = {
    Human: 'human',
    Elf: 'elf',
    Dwarf: 'dwarf',
    Halfling: 'halfling',
    Gnome: 'gnome',
    HalfElf: 'half-elf',
    HalfOrc: 'half-orc',
    Dragonborn: 'dragonborn',
    Tiefling: 'tiefling'
} as const;

export type Race = typeof Race[keyof typeof Race];


/**
 * 
 * @export
 * @interface Spell
 */
export interface Spell {
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Spell
     */
    'level': number;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'school': string;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'casting_time': string;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'range': string;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'components': string;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'duration': string;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof Spell
     */
    'requires_concentration'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Spell
     */
    'available_classes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SpellAttackBonusRequest
 */
export interface SpellAttackBonusRequest {
    /**
     * 
     * @type {CharacterClass}
     * @memberof SpellAttackBonusRequest
     */
    'character_class': CharacterClass;
    /**
     * 
     * @type {number}
     * @memberof SpellAttackBonusRequest
     */
    'level': number;
    /**
     * 
     * @type {number}
     * @memberof SpellAttackBonusRequest
     */
    'spellcasting_ability_score': number;
}


/**
 * 
 * @export
 * @interface SpellCasting
 */
export interface SpellCasting {
    /**
     * 
     * @type {string}
     * @memberof SpellCasting
     */
    'spellcasting_ability': string;
    /**
     * 
     * @type {number}
     * @memberof SpellCasting
     */
    'spell_attack_bonus'?: number;
    /**
     * 
     * @type {number}
     * @memberof SpellCasting
     */
    'spell_save_dc'?: number;
    /**
     * 
     * @type {Array<SpellSlot>}
     * @memberof SpellCasting
     */
    'spell_slots'?: Array<SpellSlot>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SpellCasting
     */
    'known_spells'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SpellCasting
     */
    'prepared_spells'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SpellCasting
     */
    'cantrips_known'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SpellCasting
     */
    'concentration_spell'?: string | null;
}
/**
 * 
 * @export
 * @interface SpellCastingResponse
 */
export interface SpellCastingResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SpellCastingResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof SpellCastingResponse
     */
    'message': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SpellCastingResponse
     */
    'spell_effects'?: { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof SpellCastingResponse
     */
    'concentration_broken'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SpellCastingResponse
     */
    'slot_used'?: boolean;
}
/**
 * 
 * @export
 * @interface SpellListResponse
 */
export interface SpellListResponse {
    /**
     * 
     * @type {Array<Spell>}
     * @memberof SpellListResponse
     */
    'spells': Array<Spell>;
    /**
     * 
     * @type {number}
     * @memberof SpellListResponse
     */
    'total_count': number;
}
/**
 * 
 * @export
 * @interface SpellSlot
 */
export interface SpellSlot {
    /**
     * 
     * @type {number}
     * @memberof SpellSlot
     */
    'level': number;
    /**
     * 
     * @type {number}
     * @memberof SpellSlot
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof SpellSlot
     */
    'used'?: number;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheckHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckHealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.healthCheckHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.healthCheckHealthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthCheckHealthGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthCheckHealthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GameApi - axios parameter creator
 * @export
 */
export const GameApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Award experience points to a character.
         * @summary Award Experience
         * @param {string} characterId 
         * @param {{ [key: string]: number | null; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        awardExperienceApiGameCharacterCharacterIdAwardExperiencePost: async (characterId: string, requestBody: { [key: string]: number | null; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('awardExperienceApiGameCharacterCharacterIdAwardExperiencePost', 'characterId', characterId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('awardExperienceApiGameCharacterCharacterIdAwardExperiencePost', 'requestBody', requestBody)
            const localVarPath = `/api/game/character/{character_id}/award-experience`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculate spell attack bonus for a character.
         * @summary Calculate Spell Attack Bonus
         * @param {SpellAttackBonusRequest} spellAttackBonusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateSpellAttackBonusApiGameSpellsAttackBonusPost: async (spellAttackBonusRequest: SpellAttackBonusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spellAttackBonusRequest' is not null or undefined
            assertParamExists('calculateSpellAttackBonusApiGameSpellsAttackBonusPost', 'spellAttackBonusRequest', spellAttackBonusRequest)
            const localVarPath = `/api/game/spells/attack-bonus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(spellAttackBonusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculate spell save DC for a character.
         * @summary Calculate Spell Save Dc Endpoint
         * @param {CharacterClass | null} characterClass 
         * @param {number} level 
         * @param {number} spellcastingAbilityScore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateSpellSaveDcEndpointApiGameSpellsSaveDcPost: async (characterClass: CharacterClass | null, level: number, spellcastingAbilityScore: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterClass' is not null or undefined
            assertParamExists('calculateSpellSaveDcEndpointApiGameSpellsSaveDcPost', 'characterClass', characterClass)
            // verify required parameter 'level' is not null or undefined
            assertParamExists('calculateSpellSaveDcEndpointApiGameSpellsSaveDcPost', 'level', level)
            // verify required parameter 'spellcastingAbilityScore' is not null or undefined
            assertParamExists('calculateSpellSaveDcEndpointApiGameSpellsSaveDcPost', 'spellcastingAbilityScore', spellcastingAbilityScore)
            const localVarPath = `/api/game/spells/save-dc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (characterClass !== undefined) {
                localVarQueryParameter['character_class'] = characterClass;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (spellcastingAbilityScore !== undefined) {
                localVarQueryParameter['spellcasting_ability_score'] = spellcastingAbilityScore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cast spells during combat with sophisticated effect resolution.
         * @summary Cast Spell In Combat
         * @param {string} combatId 
         * @param {CastSpellRequest} castSpellRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        castSpellInCombatApiGameCombatCombatIdCastSpellPost: async (combatId: string, castSpellRequest: CastSpellRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'combatId' is not null or undefined
            assertParamExists('castSpellInCombatApiGameCombatCombatIdCastSpellPost', 'combatId', combatId)
            // verify required parameter 'castSpellRequest' is not null or undefined
            assertParamExists('castSpellInCombatApiGameCombatCombatIdCastSpellPost', 'castSpellRequest', castSpellRequest)
            const localVarPath = `/api/game/combat/{combat_id}/cast-spell`
                .replace(`{${"combat_id"}}`, encodeURIComponent(String(combatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(castSpellRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clone a template campaign for customization.
         * @summary Clone Campaign
         * @param {CloneCampaignRequest} cloneCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneCampaignApiGameCampaignClonePost: async (cloneCampaignRequest: CloneCampaignRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloneCampaignRequest' is not null or undefined
            assertParamExists('cloneCampaignApiGameCampaignClonePost', 'cloneCampaignRequest', cloneCampaignRequest)
            const localVarPath = `/api/game/campaign/clone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneCampaignRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new campaign.
         * @summary Create Campaign
         * @param {CreateCampaignRequest} createCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignApiGameCampaignPost: async (createCampaignRequest: CreateCampaignRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCampaignRequest' is not null or undefined
            assertParamExists('createCampaignApiGameCampaignPost', 'createCampaignRequest', createCampaignRequest)
            const localVarPath = `/api/game/campaign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCampaignRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create and manage campaign NPCs.
         * @summary Create Campaign Npc
         * @param {string} campaignId 
         * @param {CreateNPCRequest} createNPCRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignNpcApiGameCampaignCampaignIdNpcsPost: async (campaignId: string, createNPCRequest: CreateNPCRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('createCampaignNpcApiGameCampaignCampaignIdNpcsPost', 'campaignId', campaignId)
            // verify required parameter 'createNPCRequest' is not null or undefined
            assertParamExists('createCampaignNpcApiGameCampaignCampaignIdNpcsPost', 'createNPCRequest', createNPCRequest)
            const localVarPath = `/api/game/campaign/{campaign_id}/npcs`
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNPCRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new player character.
         * @summary Create Character
         * @param {CreateCharacterRequest} createCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterApiGameCharacterPost: async (createCharacterRequest: CreateCharacterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCharacterRequest' is not null or undefined
            assertParamExists('createCharacterApiGameCharacterPost', 'createCharacterRequest', createCharacterRequest)
            const localVarPath = `/api/game/character`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCharacterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a custom campaign (templates cannot be deleted).
         * @summary Delete Campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignApiGameCampaignCampaignIdDelete: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('deleteCampaignApiGameCampaignCampaignIdDelete', 'campaignId', campaignId)
            const localVarPath = `/api/game/campaign/{campaign_id}`
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate AI content based on a specific suggestion and current text.
         * @summary Generate Ai Content
         * @param {AIContentGenerationRequest} aIContentGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAiContentApiGameCampaignAiGeneratePost: async (aIContentGenerationRequest: AIContentGenerationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aIContentGenerationRequest' is not null or undefined
            assertParamExists('generateAiContentApiGameCampaignAiGeneratePost', 'aIContentGenerationRequest', aIContentGenerationRequest)
            const localVarPath = `/api/game/campaign/ai-generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aIContentGenerationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a battle map based on environment details.
         * @summary Generate Battle Map
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateBattleMapApiGameBattleMapPost: async (requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('generateBattleMapApiGameBattleMapPost', 'requestBody', requestBody)
            const localVarPath = `/api/game/battle-map`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate world description and setting for a new campaign.
         * @summary Generate Campaign World
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCampaignWorldApiGameCampaignGenerateWorldPost: async (requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('generateCampaignWorldApiGameCampaignGenerateWorldPost', 'requestBody', requestBody)
            const localVarPath = `/api/game/campaign/generate-world`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate an image based on the request details.
         * @summary Generate Image
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateImageApiGameGenerateImagePost: async (requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('generateImageApiGameGenerateImagePost', 'requestBody', requestBody)
            const localVarPath = `/api/game/generate-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate combat stats for NPCs dynamically.
         * @summary Generate Npc Stats
         * @param {string} npcId 
         * @param {GenerateNPCStatsRequest} generateNPCStatsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateNpcStatsApiGameNpcNpcIdGenerateStatsPost: async (npcId: string, generateNPCStatsRequest: GenerateNPCStatsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'npcId' is not null or undefined
            assertParamExists('generateNpcStatsApiGameNpcNpcIdGenerateStatsPost', 'npcId', npcId)
            // verify required parameter 'generateNPCStatsRequest' is not null or undefined
            assertParamExists('generateNpcStatsApiGameNpcNpcIdGenerateStatsPost', 'generateNPCStatsRequest', generateNPCStatsRequest)
            const localVarPath = `/api/game/npc/{npc_id}/generate-stats`
                .replace(`{${"npc_id"}}`, encodeURIComponent(String(npcId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateNPCStatsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get AI assistance for campaign text enhancement.
         * @summary Get Ai Assistance
         * @param {AIAssistanceRequest} aIAssistanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAiAssistanceApiGameCampaignAiAssistPost: async (aIAssistanceRequest: AIAssistanceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aIAssistanceRequest' is not null or undefined
            assertParamExists('getAiAssistanceApiGameCampaignAiAssistPost', 'aIAssistanceRequest', aIAssistanceRequest)
            const localVarPath = `/api/game/campaign/ai-assist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aIAssistanceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific campaign by ID.
         * @summary Get Campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignApiGameCampaignCampaignIdGet: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('getCampaignApiGameCampaignCampaignIdGet', 'campaignId', campaignId)
            const localVarPath = `/api/game/campaign/{campaign_id}`
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pre-built campaign templates.
         * @summary Get Campaign Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplatesApiGameCampaignTemplatesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/game/campaign/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a character sheet by ID.
         * @summary Get Character
         * @param {string} characterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterApiGameCharacterCharacterIdGet: async (characterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharacterApiGameCharacterCharacterIdGet', 'characterId', characterId)
            const localVarPath = `/api/game/character/{character_id}`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculate carrying capacity and weight.
         * @summary Get Encumbrance
         * @param {string} characterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEncumbranceApiGameCharacterCharacterIdEncumbranceGet: async (characterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getEncumbranceApiGameCharacterCharacterIdEncumbranceGet', 'characterId', characterId)
            const localVarPath = `/api/game/character/{character_id}/encumbrance`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Browse available items with rarity and value information.
         * @summary Get Item Catalog
         * @param {ItemType | null} [itemType] 
         * @param {ItemRarity | null} [rarity] 
         * @param {number | null} [minValue] 
         * @param {number | null} [maxValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCatalogApiGameItemsCatalogGet: async (itemType?: ItemType | null, rarity?: ItemRarity | null, minValue?: number | null, maxValue?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/game/items/catalog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (itemType !== undefined) {
                localVarQueryParameter['item_type'] = itemType;
            }

            if (rarity !== undefined) {
                localVarQueryParameter['rarity'] = rarity;
            }

            if (minValue !== undefined) {
                localVarQueryParameter['min_value'] = minValue;
            }

            if (maxValue !== undefined) {
                localVarQueryParameter['max_value'] = maxValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get NPC personality traits and behaviors.
         * @summary Get Npc Personality
         * @param {string} npcId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcPersonalityApiGameNpcNpcIdPersonalityGet: async (npcId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'npcId' is not null or undefined
            assertParamExists('getNpcPersonalityApiGameNpcNpcIdPersonalityGet', 'npcId', npcId)
            const localVarPath = `/api/game/npc/{npc_id}/personality`
                .replace(`{${"npc_id"}}`, encodeURIComponent(String(npcId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get progression information for a character.
         * @summary Get Progression Info
         * @param {string} characterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgressionInfoApiGameCharacterCharacterIdProgressionInfoGet: async (characterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getProgressionInfoApiGameCharacterCharacterIdProgressionInfoGet', 'characterId', characterId)
            const localVarPath = `/api/game/character/{character_id}/progression-info`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get available spells by class and level.
         * @summary Get Spell List
         * @param {CharacterClass | null} [characterClass] 
         * @param {number | null} [spellLevel] 
         * @param {string | null} [school] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpellListApiGameSpellsListGet: async (characterClass?: CharacterClass | null, spellLevel?: number | null, school?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/game/spells/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (characterClass !== undefined) {
                localVarQueryParameter['character_class'] = characterClass;
            }

            if (spellLevel !== undefined) {
                localVarQueryParameter['spell_level'] = spellLevel;
            }

            if (school !== undefined) {
                localVarQueryParameter['school'] = school;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initialize a new combat encounter.
         * @summary Initialize Combat
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializeCombatApiGameCombatInitializePost: async (requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('initializeCombatApiGameCombatInitializePost', 'requestBody', requestBody)
            const localVarPath = `/api/game/combat/initialize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Input a manual dice roll result.
         * @summary Input Manual Roll
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inputManualRollApiGameDiceManualRollPost: async (requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('inputManualRollApiGameDiceManualRollPost', 'requestBody', requestBody)
            const localVarPath = `/api/game/dice/manual-roll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Level up a character.
         * @summary Level Up Character
         * @param {string} characterId 
         * @param {LevelUpRequest} levelUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        levelUpCharacterApiGameCharacterCharacterIdLevelUpPost: async (characterId: string, levelUpRequest: LevelUpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('levelUpCharacterApiGameCharacterCharacterIdLevelUpPost', 'characterId', characterId)
            // verify required parameter 'levelUpRequest' is not null or undefined
            assertParamExists('levelUpCharacterApiGameCharacterCharacterIdLevelUpPost', 'levelUpRequest', levelUpRequest)
            const localVarPath = `/api/game/character/{character_id}/level-up`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(levelUpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all campaigns including templates and custom campaigns.
         * @summary List Campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCampaignsApiGameCampaignsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/game/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log and retrieve NPC interaction history.
         * @summary Log Npc Interaction
         * @param {string} npcId 
         * @param {NPCInteractionRequest} nPCInteractionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logNpcInteractionApiGameNpcNpcIdInteractionPost: async (npcId: string, nPCInteractionRequest: NPCInteractionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'npcId' is not null or undefined
            assertParamExists('logNpcInteractionApiGameNpcNpcIdInteractionPost', 'npcId', npcId)
            // verify required parameter 'nPCInteractionRequest' is not null or undefined
            assertParamExists('logNpcInteractionApiGameNpcNpcIdInteractionPost', 'nPCInteractionRequest', nPCInteractionRequest)
            const localVarPath = `/api/game/npc/{npc_id}/interaction`
                .replace(`{${"npc_id"}}`, encodeURIComponent(String(npcId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nPCInteractionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manage known spells for a character.
         * @summary Manage Character Spells
         * @param {string} characterId 
         * @param {ManageSpellsRequest} manageSpellsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageCharacterSpellsApiGameCharacterCharacterIdSpellsPost: async (characterId: string, manageSpellsRequest: ManageSpellsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('manageCharacterSpellsApiGameCharacterCharacterIdSpellsPost', 'characterId', characterId)
            // verify required parameter 'manageSpellsRequest' is not null or undefined
            assertParamExists('manageCharacterSpellsApiGameCharacterCharacterIdSpellsPost', 'manageSpellsRequest', manageSpellsRequest)
            const localVarPath = `/api/game/character/{character_id}/spells`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manageSpellsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manage spell concentration tracking for a character.
         * @summary Manage Concentration
         * @param {string} characterId 
         * @param {ConcentrationRequest} concentrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageConcentrationApiGameCharacterCharacterIdConcentrationPost: async (characterId: string, concentrationRequest: ConcentrationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('manageConcentrationApiGameCharacterCharacterIdConcentrationPost', 'characterId', characterId)
            // verify required parameter 'concentrationRequest' is not null or undefined
            assertParamExists('manageConcentrationApiGameCharacterCharacterIdConcentrationPost', 'concentrationRequest', concentrationRequest)
            const localVarPath = `/api/game/character/{character_id}/concentration`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(concentrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Equip/unequip items with stat effects.
         * @summary Manage Equipment
         * @param {string} characterId 
         * @param {ManageEquipmentRequest} manageEquipmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageEquipmentApiGameCharacterCharacterIdEquipmentPost: async (characterId: string, manageEquipmentRequest: ManageEquipmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('manageEquipmentApiGameCharacterCharacterIdEquipmentPost', 'characterId', characterId)
            // verify required parameter 'manageEquipmentRequest' is not null or undefined
            assertParamExists('manageEquipmentApiGameCharacterCharacterIdEquipmentPost', 'manageEquipmentRequest', manageEquipmentRequest)
            const localVarPath = `/api/game/character/{character_id}/equipment`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manageEquipmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply magical item effects to character stats.
         * @summary Manage Magical Effects
         * @param {MagicalEffectsRequest} magicalEffectsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageMagicalEffectsApiGameItemsMagicalEffectsPost: async (magicalEffectsRequest: MagicalEffectsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'magicalEffectsRequest' is not null or undefined
            assertParamExists('manageMagicalEffectsApiGameItemsMagicalEffectsPost', 'magicalEffectsRequest', magicalEffectsRequest)
            const localVarPath = `/api/game/items/magical-effects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(magicalEffectsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manage spell slot usage and recovery for a character.
         * @summary Manage Spell Slots
         * @param {string} characterId 
         * @param {ManageSpellSlotsRequest} manageSpellSlotsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageSpellSlotsApiGameCharacterCharacterIdSpellSlotsPost: async (characterId: string, manageSpellSlotsRequest: ManageSpellSlotsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('manageSpellSlotsApiGameCharacterCharacterIdSpellSlotsPost', 'characterId', characterId)
            // verify required parameter 'manageSpellSlotsRequest' is not null or undefined
            assertParamExists('manageSpellSlotsApiGameCharacterCharacterIdSpellSlotsPost', 'manageSpellSlotsRequest', manageSpellSlotsRequest)
            const localVarPath = `/api/game/character/{character_id}/spell-slots`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manageSpellSlotsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process a single combat turn.
         * @summary Process Combat Turn
         * @param {string} combatId 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCombatTurnApiGameCombatCombatIdTurnPost: async (combatId: string, requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'combatId' is not null or undefined
            assertParamExists('processCombatTurnApiGameCombatCombatIdTurnPost', 'combatId', combatId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('processCombatTurnApiGameCombatCombatIdTurnPost', 'requestBody', requestBody)
            const localVarPath = `/api/game/combat/{combat_id}/turn`
                .replace(`{${"combat_id"}}`, encodeURIComponent(String(combatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process a player action within a game session.
         * @summary Process Player Action
         * @param {string} sessionId 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPlayerActionApiGameSessionSessionIdActionPost: async (sessionId: string, requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('processPlayerActionApiGameSessionSessionIdActionPost', 'sessionId', sessionId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('processPlayerActionApiGameSessionSessionIdActionPost', 'requestBody', requestBody)
            const localVarPath = `/api/game/session/{session_id}/action`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process player input and get game response.
         * @summary Process Player Input
         * @param {PlayerInput} playerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPlayerInputApiGameInputPost: async (playerInput: PlayerInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playerInput' is not null or undefined
            assertParamExists('processPlayerInputApiGameInputPost', 'playerInput', playerInput)
            const localVarPath = `/api/game/input`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Roll dice using D&D notation.
         * @summary Roll Dice
         * @param {{ [key: string]: string | null; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollDiceApiGameDiceRollPost: async (requestBody: { [key: string]: string | null; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('rollDiceApiGameDiceRollPost', 'requestBody', requestBody)
            const localVarPath = `/api/game/dice/roll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Roll dice with character context for skill checks.
         * @summary Roll Dice With Character
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollDiceWithCharacterApiGameDiceRollWithCharacterPost: async (requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('rollDiceWithCharacterApiGameDiceRollWithCharacterPost', 'requestBody', requestBody)
            const localVarPath = `/api/game/dice/roll-with-character`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new game session for a campaign.
         * @summary Start Game Session
         * @param {string} campaignId 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startGameSessionApiGameCampaignCampaignIdStartSessionPost: async (campaignId: string, requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('startGameSessionApiGameCampaignCampaignIdStartSessionPost', 'campaignId', campaignId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('startGameSessionApiGameCampaignCampaignIdStartSessionPost', 'requestBody', requestBody)
            const localVarPath = `/api/game/campaign/{campaign_id}/start-session`
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing campaign.
         * @summary Update Campaign
         * @param {string} campaignId 
         * @param {CampaignUpdateRequest} campaignUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaignApiGameCampaignCampaignIdPut: async (campaignId: string, campaignUpdateRequest: CampaignUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('updateCampaignApiGameCampaignCampaignIdPut', 'campaignId', campaignId)
            // verify required parameter 'campaignUpdateRequest' is not null or undefined
            assertParamExists('updateCampaignApiGameCampaignCampaignIdPut', 'campaignUpdateRequest', campaignUpdateRequest)
            const localVarPath = `/api/game/campaign/{campaign_id}`
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameApi - functional programming interface
 * @export
 */
export const GameApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GameApiAxiosParamCreator(configuration)
    return {
        /**
         * Award experience points to a character.
         * @summary Award Experience
         * @param {string} characterId 
         * @param {{ [key: string]: number | null; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async awardExperienceApiGameCharacterCharacterIdAwardExperiencePost(characterId: string, requestBody: { [key: string]: number | null; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.awardExperienceApiGameCharacterCharacterIdAwardExperiencePost(characterId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.awardExperienceApiGameCharacterCharacterIdAwardExperiencePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calculate spell attack bonus for a character.
         * @summary Calculate Spell Attack Bonus
         * @param {SpellAttackBonusRequest} spellAttackBonusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateSpellAttackBonusApiGameSpellsAttackBonusPost(spellAttackBonusRequest: SpellAttackBonusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculateSpellAttackBonusApiGameSpellsAttackBonusPost(spellAttackBonusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.calculateSpellAttackBonusApiGameSpellsAttackBonusPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calculate spell save DC for a character.
         * @summary Calculate Spell Save Dc Endpoint
         * @param {CharacterClass | null} characterClass 
         * @param {number} level 
         * @param {number} spellcastingAbilityScore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateSpellSaveDcEndpointApiGameSpellsSaveDcPost(characterClass: CharacterClass | null, level: number, spellcastingAbilityScore: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculateSpellSaveDcEndpointApiGameSpellsSaveDcPost(characterClass, level, spellcastingAbilityScore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.calculateSpellSaveDcEndpointApiGameSpellsSaveDcPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cast spells during combat with sophisticated effect resolution.
         * @summary Cast Spell In Combat
         * @param {string} combatId 
         * @param {CastSpellRequest} castSpellRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async castSpellInCombatApiGameCombatCombatIdCastSpellPost(combatId: string, castSpellRequest: CastSpellRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpellCastingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.castSpellInCombatApiGameCombatCombatIdCastSpellPost(combatId, castSpellRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.castSpellInCombatApiGameCombatCombatIdCastSpellPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clone a template campaign for customization.
         * @summary Clone Campaign
         * @param {CloneCampaignRequest} cloneCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneCampaignApiGameCampaignClonePost(cloneCampaignRequest: CloneCampaignRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneCampaignApiGameCampaignClonePost(cloneCampaignRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.cloneCampaignApiGameCampaignClonePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new campaign.
         * @summary Create Campaign
         * @param {CreateCampaignRequest} createCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaignApiGameCampaignPost(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaignApiGameCampaignPost(createCampaignRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.createCampaignApiGameCampaignPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create and manage campaign NPCs.
         * @summary Create Campaign Npc
         * @param {string} campaignId 
         * @param {CreateNPCRequest} createNPCRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaignNpcApiGameCampaignCampaignIdNpcsPost(campaignId: string, createNPCRequest: CreateNPCRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NPC>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaignNpcApiGameCampaignCampaignIdNpcsPost(campaignId, createNPCRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.createCampaignNpcApiGameCampaignCampaignIdNpcsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new player character.
         * @summary Create Character
         * @param {CreateCharacterRequest} createCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterApiGameCharacterPost(createCharacterRequest: CreateCharacterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterSheet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCharacterApiGameCharacterPost(createCharacterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.createCharacterApiGameCharacterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a custom campaign (templates cannot be deleted).
         * @summary Delete Campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaignApiGameCampaignCampaignIdDelete(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaignApiGameCampaignCampaignIdDelete(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.deleteCampaignApiGameCampaignCampaignIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate AI content based on a specific suggestion and current text.
         * @summary Generate Ai Content
         * @param {AIContentGenerationRequest} aIContentGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateAiContentApiGameCampaignAiGeneratePost(aIContentGenerationRequest: AIContentGenerationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIContentGenerationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateAiContentApiGameCampaignAiGeneratePost(aIContentGenerationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.generateAiContentApiGameCampaignAiGeneratePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a battle map based on environment details.
         * @summary Generate Battle Map
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateBattleMapApiGameBattleMapPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateBattleMapApiGameBattleMapPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.generateBattleMapApiGameBattleMapPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate world description and setting for a new campaign.
         * @summary Generate Campaign World
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateCampaignWorldApiGameCampaignGenerateWorldPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateCampaignWorldApiGameCampaignGenerateWorldPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.generateCampaignWorldApiGameCampaignGenerateWorldPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate an image based on the request details.
         * @summary Generate Image
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateImageApiGameGenerateImagePost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateImageApiGameGenerateImagePost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.generateImageApiGameGenerateImagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate combat stats for NPCs dynamically.
         * @summary Generate Npc Stats
         * @param {string} npcId 
         * @param {GenerateNPCStatsRequest} generateNPCStatsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateNpcStatsApiGameNpcNpcIdGenerateStatsPost(npcId: string, generateNPCStatsRequest: GenerateNPCStatsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NPCStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateNpcStatsApiGameNpcNpcIdGenerateStatsPost(npcId, generateNPCStatsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.generateNpcStatsApiGameNpcNpcIdGenerateStatsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get AI assistance for campaign text enhancement.
         * @summary Get Ai Assistance
         * @param {AIAssistanceRequest} aIAssistanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAiAssistanceApiGameCampaignAiAssistPost(aIAssistanceRequest: AIAssistanceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAssistanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAiAssistanceApiGameCampaignAiAssistPost(aIAssistanceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getAiAssistanceApiGameCampaignAiAssistPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific campaign by ID.
         * @summary Get Campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignApiGameCampaignCampaignIdGet(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignApiGameCampaignCampaignIdGet(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getCampaignApiGameCampaignCampaignIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pre-built campaign templates.
         * @summary Get Campaign Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignTemplatesApiGameCampaignTemplatesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignTemplatesApiGameCampaignTemplatesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getCampaignTemplatesApiGameCampaignTemplatesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a character sheet by ID.
         * @summary Get Character
         * @param {string} characterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterApiGameCharacterCharacterIdGet(characterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharacterApiGameCharacterCharacterIdGet(characterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getCharacterApiGameCharacterCharacterIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calculate carrying capacity and weight.
         * @summary Get Encumbrance
         * @param {string} characterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEncumbranceApiGameCharacterCharacterIdEncumbranceGet(characterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EncumbranceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEncumbranceApiGameCharacterCharacterIdEncumbranceGet(characterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getEncumbranceApiGameCharacterCharacterIdEncumbranceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Browse available items with rarity and value information.
         * @summary Get Item Catalog
         * @param {ItemType | null} [itemType] 
         * @param {ItemRarity | null} [rarity] 
         * @param {number | null} [minValue] 
         * @param {number | null} [maxValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemCatalogApiGameItemsCatalogGet(itemType?: ItemType | null, rarity?: ItemRarity | null, minValue?: number | null, maxValue?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemCatalogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemCatalogApiGameItemsCatalogGet(itemType, rarity, minValue, maxValue, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getItemCatalogApiGameItemsCatalogGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get NPC personality traits and behaviors.
         * @summary Get Npc Personality
         * @param {string} npcId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNpcPersonalityApiGameNpcNpcIdPersonalityGet(npcId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NPCPersonality>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNpcPersonalityApiGameNpcNpcIdPersonalityGet(npcId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getNpcPersonalityApiGameNpcNpcIdPersonalityGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get progression information for a character.
         * @summary Get Progression Info
         * @param {string} characterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgressionInfoApiGameCharacterCharacterIdProgressionInfoGet(characterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgressionInfoApiGameCharacterCharacterIdProgressionInfoGet(characterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getProgressionInfoApiGameCharacterCharacterIdProgressionInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get available spells by class and level.
         * @summary Get Spell List
         * @param {CharacterClass | null} [characterClass] 
         * @param {number | null} [spellLevel] 
         * @param {string | null} [school] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpellListApiGameSpellsListGet(characterClass?: CharacterClass | null, spellLevel?: number | null, school?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpellListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpellListApiGameSpellsListGet(characterClass, spellLevel, school, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getSpellListApiGameSpellsListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initialize a new combat encounter.
         * @summary Initialize Combat
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initializeCombatApiGameCombatInitializePost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initializeCombatApiGameCombatInitializePost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.initializeCombatApiGameCombatInitializePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Input a manual dice roll result.
         * @summary Input Manual Roll
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inputManualRollApiGameDiceManualRollPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inputManualRollApiGameDiceManualRollPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.inputManualRollApiGameDiceManualRollPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Level up a character.
         * @summary Level Up Character
         * @param {string} characterId 
         * @param {LevelUpRequest} levelUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async levelUpCharacterApiGameCharacterCharacterIdLevelUpPost(characterId: string, levelUpRequest: LevelUpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.levelUpCharacterApiGameCharacterCharacterIdLevelUpPost(characterId, levelUpRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.levelUpCharacterApiGameCharacterCharacterIdLevelUpPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all campaigns including templates and custom campaigns.
         * @summary List Campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCampaignsApiGameCampaignsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCampaignsApiGameCampaignsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.listCampaignsApiGameCampaignsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Log and retrieve NPC interaction history.
         * @summary Log Npc Interaction
         * @param {string} npcId 
         * @param {NPCInteractionRequest} nPCInteractionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logNpcInteractionApiGameNpcNpcIdInteractionPost(npcId: string, nPCInteractionRequest: NPCInteractionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NPCInteractionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logNpcInteractionApiGameNpcNpcIdInteractionPost(npcId, nPCInteractionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.logNpcInteractionApiGameNpcNpcIdInteractionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Manage known spells for a character.
         * @summary Manage Character Spells
         * @param {string} characterId 
         * @param {ManageSpellsRequest} manageSpellsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageCharacterSpellsApiGameCharacterCharacterIdSpellsPost(characterId: string, manageSpellsRequest: ManageSpellsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageCharacterSpellsApiGameCharacterCharacterIdSpellsPost(characterId, manageSpellsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.manageCharacterSpellsApiGameCharacterCharacterIdSpellsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Manage spell concentration tracking for a character.
         * @summary Manage Concentration
         * @param {string} characterId 
         * @param {ConcentrationRequest} concentrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageConcentrationApiGameCharacterCharacterIdConcentrationPost(characterId: string, concentrationRequest: ConcentrationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConcentrationCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageConcentrationApiGameCharacterCharacterIdConcentrationPost(characterId, concentrationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.manageConcentrationApiGameCharacterCharacterIdConcentrationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Equip/unequip items with stat effects.
         * @summary Manage Equipment
         * @param {string} characterId 
         * @param {ManageEquipmentRequest} manageEquipmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageEquipmentApiGameCharacterCharacterIdEquipmentPost(characterId: string, manageEquipmentRequest: ManageEquipmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EquipmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageEquipmentApiGameCharacterCharacterIdEquipmentPost(characterId, manageEquipmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.manageEquipmentApiGameCharacterCharacterIdEquipmentPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Apply magical item effects to character stats.
         * @summary Manage Magical Effects
         * @param {MagicalEffectsRequest} magicalEffectsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageMagicalEffectsApiGameItemsMagicalEffectsPost(magicalEffectsRequest: MagicalEffectsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MagicalEffectsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageMagicalEffectsApiGameItemsMagicalEffectsPost(magicalEffectsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.manageMagicalEffectsApiGameItemsMagicalEffectsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Manage spell slot usage and recovery for a character.
         * @summary Manage Spell Slots
         * @param {string} characterId 
         * @param {ManageSpellSlotsRequest} manageSpellSlotsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageSpellSlotsApiGameCharacterCharacterIdSpellSlotsPost(characterId: string, manageSpellSlotsRequest: ManageSpellSlotsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageSpellSlotsApiGameCharacterCharacterIdSpellSlotsPost(characterId, manageSpellSlotsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.manageSpellSlotsApiGameCharacterCharacterIdSpellSlotsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Process a single combat turn.
         * @summary Process Combat Turn
         * @param {string} combatId 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processCombatTurnApiGameCombatCombatIdTurnPost(combatId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processCombatTurnApiGameCombatCombatIdTurnPost(combatId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.processCombatTurnApiGameCombatCombatIdTurnPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Process a player action within a game session.
         * @summary Process Player Action
         * @param {string} sessionId 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processPlayerActionApiGameSessionSessionIdActionPost(sessionId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processPlayerActionApiGameSessionSessionIdActionPost(sessionId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.processPlayerActionApiGameSessionSessionIdActionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Process player input and get game response.
         * @summary Process Player Input
         * @param {PlayerInput} playerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processPlayerInputApiGameInputPost(playerInput: PlayerInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processPlayerInputApiGameInputPost(playerInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.processPlayerInputApiGameInputPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Roll dice using D&D notation.
         * @summary Roll Dice
         * @param {{ [key: string]: string | null; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rollDiceApiGameDiceRollPost(requestBody: { [key: string]: string | null; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rollDiceApiGameDiceRollPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.rollDiceApiGameDiceRollPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Roll dice with character context for skill checks.
         * @summary Roll Dice With Character
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rollDiceWithCharacterApiGameDiceRollWithCharacterPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rollDiceWithCharacterApiGameDiceRollWithCharacterPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.rollDiceWithCharacterApiGameDiceRollWithCharacterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a new game session for a campaign.
         * @summary Start Game Session
         * @param {string} campaignId 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startGameSessionApiGameCampaignCampaignIdStartSessionPost(campaignId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startGameSessionApiGameCampaignCampaignIdStartSessionPost(campaignId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.startGameSessionApiGameCampaignCampaignIdStartSessionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing campaign.
         * @summary Update Campaign
         * @param {string} campaignId 
         * @param {CampaignUpdateRequest} campaignUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCampaignApiGameCampaignCampaignIdPut(campaignId: string, campaignUpdateRequest: CampaignUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCampaignApiGameCampaignCampaignIdPut(campaignId, campaignUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.updateCampaignApiGameCampaignCampaignIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GameApi - factory interface
 * @export
 */
export const GameApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GameApiFp(configuration)
    return {
        /**
         * Award experience points to a character.
         * @summary Award Experience
         * @param {string} characterId 
         * @param {{ [key: string]: number | null; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        awardExperienceApiGameCharacterCharacterIdAwardExperiencePost(characterId: string, requestBody: { [key: string]: number | null; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.awardExperienceApiGameCharacterCharacterIdAwardExperiencePost(characterId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculate spell attack bonus for a character.
         * @summary Calculate Spell Attack Bonus
         * @param {SpellAttackBonusRequest} spellAttackBonusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateSpellAttackBonusApiGameSpellsAttackBonusPost(spellAttackBonusRequest: SpellAttackBonusRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.calculateSpellAttackBonusApiGameSpellsAttackBonusPost(spellAttackBonusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculate spell save DC for a character.
         * @summary Calculate Spell Save Dc Endpoint
         * @param {CharacterClass | null} characterClass 
         * @param {number} level 
         * @param {number} spellcastingAbilityScore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateSpellSaveDcEndpointApiGameSpellsSaveDcPost(characterClass: CharacterClass | null, level: number, spellcastingAbilityScore: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.calculateSpellSaveDcEndpointApiGameSpellsSaveDcPost(characterClass, level, spellcastingAbilityScore, options).then((request) => request(axios, basePath));
        },
        /**
         * Cast spells during combat with sophisticated effect resolution.
         * @summary Cast Spell In Combat
         * @param {string} combatId 
         * @param {CastSpellRequest} castSpellRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        castSpellInCombatApiGameCombatCombatIdCastSpellPost(combatId: string, castSpellRequest: CastSpellRequest, options?: RawAxiosRequestConfig): AxiosPromise<SpellCastingResponse> {
            return localVarFp.castSpellInCombatApiGameCombatCombatIdCastSpellPost(combatId, castSpellRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Clone a template campaign for customization.
         * @summary Clone Campaign
         * @param {CloneCampaignRequest} cloneCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneCampaignApiGameCampaignClonePost(cloneCampaignRequest: CloneCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.cloneCampaignApiGameCampaignClonePost(cloneCampaignRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new campaign.
         * @summary Create Campaign
         * @param {CreateCampaignRequest} createCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignApiGameCampaignPost(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.createCampaignApiGameCampaignPost(createCampaignRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create and manage campaign NPCs.
         * @summary Create Campaign Npc
         * @param {string} campaignId 
         * @param {CreateNPCRequest} createNPCRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignNpcApiGameCampaignCampaignIdNpcsPost(campaignId: string, createNPCRequest: CreateNPCRequest, options?: RawAxiosRequestConfig): AxiosPromise<NPC> {
            return localVarFp.createCampaignNpcApiGameCampaignCampaignIdNpcsPost(campaignId, createNPCRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new player character.
         * @summary Create Character
         * @param {CreateCharacterRequest} createCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterApiGameCharacterPost(createCharacterRequest: CreateCharacterRequest, options?: RawAxiosRequestConfig): AxiosPromise<CharacterSheet> {
            return localVarFp.createCharacterApiGameCharacterPost(createCharacterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a custom campaign (templates cannot be deleted).
         * @summary Delete Campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignApiGameCampaignCampaignIdDelete(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteCampaignApiGameCampaignCampaignIdDelete(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate AI content based on a specific suggestion and current text.
         * @summary Generate Ai Content
         * @param {AIContentGenerationRequest} aIContentGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAiContentApiGameCampaignAiGeneratePost(aIContentGenerationRequest: AIContentGenerationRequest, options?: RawAxiosRequestConfig): AxiosPromise<AIContentGenerationResponse> {
            return localVarFp.generateAiContentApiGameCampaignAiGeneratePost(aIContentGenerationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a battle map based on environment details.
         * @summary Generate Battle Map
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateBattleMapApiGameBattleMapPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.generateBattleMapApiGameBattleMapPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate world description and setting for a new campaign.
         * @summary Generate Campaign World
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCampaignWorldApiGameCampaignGenerateWorldPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.generateCampaignWorldApiGameCampaignGenerateWorldPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate an image based on the request details.
         * @summary Generate Image
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateImageApiGameGenerateImagePost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.generateImageApiGameGenerateImagePost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate combat stats for NPCs dynamically.
         * @summary Generate Npc Stats
         * @param {string} npcId 
         * @param {GenerateNPCStatsRequest} generateNPCStatsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateNpcStatsApiGameNpcNpcIdGenerateStatsPost(npcId: string, generateNPCStatsRequest: GenerateNPCStatsRequest, options?: RawAxiosRequestConfig): AxiosPromise<NPCStatsResponse> {
            return localVarFp.generateNpcStatsApiGameNpcNpcIdGenerateStatsPost(npcId, generateNPCStatsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get AI assistance for campaign text enhancement.
         * @summary Get Ai Assistance
         * @param {AIAssistanceRequest} aIAssistanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAiAssistanceApiGameCampaignAiAssistPost(aIAssistanceRequest: AIAssistanceRequest, options?: RawAxiosRequestConfig): AxiosPromise<AIAssistanceResponse> {
            return localVarFp.getAiAssistanceApiGameCampaignAiAssistPost(aIAssistanceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific campaign by ID.
         * @summary Get Campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignApiGameCampaignCampaignIdGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.getCampaignApiGameCampaignCampaignIdGet(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pre-built campaign templates.
         * @summary Get Campaign Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplatesApiGameCampaignTemplatesGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getCampaignTemplatesApiGameCampaignTemplatesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a character sheet by ID.
         * @summary Get Character
         * @param {string} characterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterApiGameCharacterCharacterIdGet(characterId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getCharacterApiGameCharacterCharacterIdGet(characterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculate carrying capacity and weight.
         * @summary Get Encumbrance
         * @param {string} characterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEncumbranceApiGameCharacterCharacterIdEncumbranceGet(characterId: string, options?: RawAxiosRequestConfig): AxiosPromise<EncumbranceResponse> {
            return localVarFp.getEncumbranceApiGameCharacterCharacterIdEncumbranceGet(characterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Browse available items with rarity and value information.
         * @summary Get Item Catalog
         * @param {ItemType | null} [itemType] 
         * @param {ItemRarity | null} [rarity] 
         * @param {number | null} [minValue] 
         * @param {number | null} [maxValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCatalogApiGameItemsCatalogGet(itemType?: ItemType | null, rarity?: ItemRarity | null, minValue?: number | null, maxValue?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<ItemCatalogResponse> {
            return localVarFp.getItemCatalogApiGameItemsCatalogGet(itemType, rarity, minValue, maxValue, options).then((request) => request(axios, basePath));
        },
        /**
         * Get NPC personality traits and behaviors.
         * @summary Get Npc Personality
         * @param {string} npcId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcPersonalityApiGameNpcNpcIdPersonalityGet(npcId: string, options?: RawAxiosRequestConfig): AxiosPromise<NPCPersonality> {
            return localVarFp.getNpcPersonalityApiGameNpcNpcIdPersonalityGet(npcId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get progression information for a character.
         * @summary Get Progression Info
         * @param {string} characterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgressionInfoApiGameCharacterCharacterIdProgressionInfoGet(characterId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getProgressionInfoApiGameCharacterCharacterIdProgressionInfoGet(characterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get available spells by class and level.
         * @summary Get Spell List
         * @param {CharacterClass | null} [characterClass] 
         * @param {number | null} [spellLevel] 
         * @param {string | null} [school] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpellListApiGameSpellsListGet(characterClass?: CharacterClass | null, spellLevel?: number | null, school?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<SpellListResponse> {
            return localVarFp.getSpellListApiGameSpellsListGet(characterClass, spellLevel, school, options).then((request) => request(axios, basePath));
        },
        /**
         * Initialize a new combat encounter.
         * @summary Initialize Combat
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializeCombatApiGameCombatInitializePost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.initializeCombatApiGameCombatInitializePost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Input a manual dice roll result.
         * @summary Input Manual Roll
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inputManualRollApiGameDiceManualRollPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.inputManualRollApiGameDiceManualRollPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Level up a character.
         * @summary Level Up Character
         * @param {string} characterId 
         * @param {LevelUpRequest} levelUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        levelUpCharacterApiGameCharacterCharacterIdLevelUpPost(characterId: string, levelUpRequest: LevelUpRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.levelUpCharacterApiGameCharacterCharacterIdLevelUpPost(characterId, levelUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List all campaigns including templates and custom campaigns.
         * @summary List Campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCampaignsApiGameCampaignsGet(options?: RawAxiosRequestConfig): AxiosPromise<CampaignListResponse> {
            return localVarFp.listCampaignsApiGameCampaignsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Log and retrieve NPC interaction history.
         * @summary Log Npc Interaction
         * @param {string} npcId 
         * @param {NPCInteractionRequest} nPCInteractionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logNpcInteractionApiGameNpcNpcIdInteractionPost(npcId: string, nPCInteractionRequest: NPCInteractionRequest, options?: RawAxiosRequestConfig): AxiosPromise<NPCInteractionResponse> {
            return localVarFp.logNpcInteractionApiGameNpcNpcIdInteractionPost(npcId, nPCInteractionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Manage known spells for a character.
         * @summary Manage Character Spells
         * @param {string} characterId 
         * @param {ManageSpellsRequest} manageSpellsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageCharacterSpellsApiGameCharacterCharacterIdSpellsPost(characterId: string, manageSpellsRequest: ManageSpellsRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.manageCharacterSpellsApiGameCharacterCharacterIdSpellsPost(characterId, manageSpellsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Manage spell concentration tracking for a character.
         * @summary Manage Concentration
         * @param {string} characterId 
         * @param {ConcentrationRequest} concentrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageConcentrationApiGameCharacterCharacterIdConcentrationPost(characterId: string, concentrationRequest: ConcentrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConcentrationCheckResponse> {
            return localVarFp.manageConcentrationApiGameCharacterCharacterIdConcentrationPost(characterId, concentrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Equip/unequip items with stat effects.
         * @summary Manage Equipment
         * @param {string} characterId 
         * @param {ManageEquipmentRequest} manageEquipmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageEquipmentApiGameCharacterCharacterIdEquipmentPost(characterId: string, manageEquipmentRequest: ManageEquipmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<EquipmentResponse> {
            return localVarFp.manageEquipmentApiGameCharacterCharacterIdEquipmentPost(characterId, manageEquipmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply magical item effects to character stats.
         * @summary Manage Magical Effects
         * @param {MagicalEffectsRequest} magicalEffectsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageMagicalEffectsApiGameItemsMagicalEffectsPost(magicalEffectsRequest: MagicalEffectsRequest, options?: RawAxiosRequestConfig): AxiosPromise<MagicalEffectsResponse> {
            return localVarFp.manageMagicalEffectsApiGameItemsMagicalEffectsPost(magicalEffectsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Manage spell slot usage and recovery for a character.
         * @summary Manage Spell Slots
         * @param {string} characterId 
         * @param {ManageSpellSlotsRequest} manageSpellSlotsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageSpellSlotsApiGameCharacterCharacterIdSpellSlotsPost(characterId: string, manageSpellSlotsRequest: ManageSpellSlotsRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.manageSpellSlotsApiGameCharacterCharacterIdSpellSlotsPost(characterId, manageSpellSlotsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Process a single combat turn.
         * @summary Process Combat Turn
         * @param {string} combatId 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCombatTurnApiGameCombatCombatIdTurnPost(combatId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.processCombatTurnApiGameCombatCombatIdTurnPost(combatId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Process a player action within a game session.
         * @summary Process Player Action
         * @param {string} sessionId 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPlayerActionApiGameSessionSessionIdActionPost(sessionId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.processPlayerActionApiGameSessionSessionIdActionPost(sessionId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Process player input and get game response.
         * @summary Process Player Input
         * @param {PlayerInput} playerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPlayerInputApiGameInputPost(playerInput: PlayerInput, options?: RawAxiosRequestConfig): AxiosPromise<GameResponse> {
            return localVarFp.processPlayerInputApiGameInputPost(playerInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Roll dice using D&D notation.
         * @summary Roll Dice
         * @param {{ [key: string]: string | null; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollDiceApiGameDiceRollPost(requestBody: { [key: string]: string | null; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.rollDiceApiGameDiceRollPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Roll dice with character context for skill checks.
         * @summary Roll Dice With Character
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollDiceWithCharacterApiGameDiceRollWithCharacterPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.rollDiceWithCharacterApiGameDiceRollWithCharacterPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new game session for a campaign.
         * @summary Start Game Session
         * @param {string} campaignId 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startGameSessionApiGameCampaignCampaignIdStartSessionPost(campaignId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.startGameSessionApiGameCampaignCampaignIdStartSessionPost(campaignId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing campaign.
         * @summary Update Campaign
         * @param {string} campaignId 
         * @param {CampaignUpdateRequest} campaignUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaignApiGameCampaignCampaignIdPut(campaignId: string, campaignUpdateRequest: CampaignUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.updateCampaignApiGameCampaignCampaignIdPut(campaignId, campaignUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GameApi - object-oriented interface
 * @export
 * @class GameApi
 * @extends {BaseAPI}
 */
export class GameApi extends BaseAPI {
    /**
     * Award experience points to a character.
     * @summary Award Experience
     * @param {string} characterId 
     * @param {{ [key: string]: number | null; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public awardExperienceApiGameCharacterCharacterIdAwardExperiencePost(characterId: string, requestBody: { [key: string]: number | null; }, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).awardExperienceApiGameCharacterCharacterIdAwardExperiencePost(characterId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calculate spell attack bonus for a character.
     * @summary Calculate Spell Attack Bonus
     * @param {SpellAttackBonusRequest} spellAttackBonusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public calculateSpellAttackBonusApiGameSpellsAttackBonusPost(spellAttackBonusRequest: SpellAttackBonusRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).calculateSpellAttackBonusApiGameSpellsAttackBonusPost(spellAttackBonusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calculate spell save DC for a character.
     * @summary Calculate Spell Save Dc Endpoint
     * @param {CharacterClass | null} characterClass 
     * @param {number} level 
     * @param {number} spellcastingAbilityScore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public calculateSpellSaveDcEndpointApiGameSpellsSaveDcPost(characterClass: CharacterClass | null, level: number, spellcastingAbilityScore: number, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).calculateSpellSaveDcEndpointApiGameSpellsSaveDcPost(characterClass, level, spellcastingAbilityScore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cast spells during combat with sophisticated effect resolution.
     * @summary Cast Spell In Combat
     * @param {string} combatId 
     * @param {CastSpellRequest} castSpellRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public castSpellInCombatApiGameCombatCombatIdCastSpellPost(combatId: string, castSpellRequest: CastSpellRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).castSpellInCombatApiGameCombatCombatIdCastSpellPost(combatId, castSpellRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clone a template campaign for customization.
     * @summary Clone Campaign
     * @param {CloneCampaignRequest} cloneCampaignRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public cloneCampaignApiGameCampaignClonePost(cloneCampaignRequest: CloneCampaignRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).cloneCampaignApiGameCampaignClonePost(cloneCampaignRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new campaign.
     * @summary Create Campaign
     * @param {CreateCampaignRequest} createCampaignRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public createCampaignApiGameCampaignPost(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).createCampaignApiGameCampaignPost(createCampaignRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create and manage campaign NPCs.
     * @summary Create Campaign Npc
     * @param {string} campaignId 
     * @param {CreateNPCRequest} createNPCRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public createCampaignNpcApiGameCampaignCampaignIdNpcsPost(campaignId: string, createNPCRequest: CreateNPCRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).createCampaignNpcApiGameCampaignCampaignIdNpcsPost(campaignId, createNPCRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new player character.
     * @summary Create Character
     * @param {CreateCharacterRequest} createCharacterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public createCharacterApiGameCharacterPost(createCharacterRequest: CreateCharacterRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).createCharacterApiGameCharacterPost(createCharacterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a custom campaign (templates cannot be deleted).
     * @summary Delete Campaign
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public deleteCampaignApiGameCampaignCampaignIdDelete(campaignId: string, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).deleteCampaignApiGameCampaignCampaignIdDelete(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate AI content based on a specific suggestion and current text.
     * @summary Generate Ai Content
     * @param {AIContentGenerationRequest} aIContentGenerationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public generateAiContentApiGameCampaignAiGeneratePost(aIContentGenerationRequest: AIContentGenerationRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).generateAiContentApiGameCampaignAiGeneratePost(aIContentGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a battle map based on environment details.
     * @summary Generate Battle Map
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public generateBattleMapApiGameBattleMapPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).generateBattleMapApiGameBattleMapPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate world description and setting for a new campaign.
     * @summary Generate Campaign World
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public generateCampaignWorldApiGameCampaignGenerateWorldPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).generateCampaignWorldApiGameCampaignGenerateWorldPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate an image based on the request details.
     * @summary Generate Image
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public generateImageApiGameGenerateImagePost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).generateImageApiGameGenerateImagePost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate combat stats for NPCs dynamically.
     * @summary Generate Npc Stats
     * @param {string} npcId 
     * @param {GenerateNPCStatsRequest} generateNPCStatsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public generateNpcStatsApiGameNpcNpcIdGenerateStatsPost(npcId: string, generateNPCStatsRequest: GenerateNPCStatsRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).generateNpcStatsApiGameNpcNpcIdGenerateStatsPost(npcId, generateNPCStatsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get AI assistance for campaign text enhancement.
     * @summary Get Ai Assistance
     * @param {AIAssistanceRequest} aIAssistanceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public getAiAssistanceApiGameCampaignAiAssistPost(aIAssistanceRequest: AIAssistanceRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getAiAssistanceApiGameCampaignAiAssistPost(aIAssistanceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific campaign by ID.
     * @summary Get Campaign
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public getCampaignApiGameCampaignCampaignIdGet(campaignId: string, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getCampaignApiGameCampaignCampaignIdGet(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pre-built campaign templates.
     * @summary Get Campaign Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public getCampaignTemplatesApiGameCampaignTemplatesGet(options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getCampaignTemplatesApiGameCampaignTemplatesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a character sheet by ID.
     * @summary Get Character
     * @param {string} characterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public getCharacterApiGameCharacterCharacterIdGet(characterId: string, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getCharacterApiGameCharacterCharacterIdGet(characterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calculate carrying capacity and weight.
     * @summary Get Encumbrance
     * @param {string} characterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public getEncumbranceApiGameCharacterCharacterIdEncumbranceGet(characterId: string, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getEncumbranceApiGameCharacterCharacterIdEncumbranceGet(characterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Browse available items with rarity and value information.
     * @summary Get Item Catalog
     * @param {ItemType | null} [itemType] 
     * @param {ItemRarity | null} [rarity] 
     * @param {number | null} [minValue] 
     * @param {number | null} [maxValue] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public getItemCatalogApiGameItemsCatalogGet(itemType?: ItemType | null, rarity?: ItemRarity | null, minValue?: number | null, maxValue?: number | null, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getItemCatalogApiGameItemsCatalogGet(itemType, rarity, minValue, maxValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get NPC personality traits and behaviors.
     * @summary Get Npc Personality
     * @param {string} npcId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public getNpcPersonalityApiGameNpcNpcIdPersonalityGet(npcId: string, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getNpcPersonalityApiGameNpcNpcIdPersonalityGet(npcId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get progression information for a character.
     * @summary Get Progression Info
     * @param {string} characterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public getProgressionInfoApiGameCharacterCharacterIdProgressionInfoGet(characterId: string, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getProgressionInfoApiGameCharacterCharacterIdProgressionInfoGet(characterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get available spells by class and level.
     * @summary Get Spell List
     * @param {CharacterClass | null} [characterClass] 
     * @param {number | null} [spellLevel] 
     * @param {string | null} [school] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public getSpellListApiGameSpellsListGet(characterClass?: CharacterClass | null, spellLevel?: number | null, school?: string | null, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getSpellListApiGameSpellsListGet(characterClass, spellLevel, school, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initialize a new combat encounter.
     * @summary Initialize Combat
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public initializeCombatApiGameCombatInitializePost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).initializeCombatApiGameCombatInitializePost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Input a manual dice roll result.
     * @summary Input Manual Roll
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public inputManualRollApiGameDiceManualRollPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).inputManualRollApiGameDiceManualRollPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Level up a character.
     * @summary Level Up Character
     * @param {string} characterId 
     * @param {LevelUpRequest} levelUpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public levelUpCharacterApiGameCharacterCharacterIdLevelUpPost(characterId: string, levelUpRequest: LevelUpRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).levelUpCharacterApiGameCharacterCharacterIdLevelUpPost(characterId, levelUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all campaigns including templates and custom campaigns.
     * @summary List Campaigns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public listCampaignsApiGameCampaignsGet(options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).listCampaignsApiGameCampaignsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Log and retrieve NPC interaction history.
     * @summary Log Npc Interaction
     * @param {string} npcId 
     * @param {NPCInteractionRequest} nPCInteractionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public logNpcInteractionApiGameNpcNpcIdInteractionPost(npcId: string, nPCInteractionRequest: NPCInteractionRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).logNpcInteractionApiGameNpcNpcIdInteractionPost(npcId, nPCInteractionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manage known spells for a character.
     * @summary Manage Character Spells
     * @param {string} characterId 
     * @param {ManageSpellsRequest} manageSpellsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public manageCharacterSpellsApiGameCharacterCharacterIdSpellsPost(characterId: string, manageSpellsRequest: ManageSpellsRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).manageCharacterSpellsApiGameCharacterCharacterIdSpellsPost(characterId, manageSpellsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manage spell concentration tracking for a character.
     * @summary Manage Concentration
     * @param {string} characterId 
     * @param {ConcentrationRequest} concentrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public manageConcentrationApiGameCharacterCharacterIdConcentrationPost(characterId: string, concentrationRequest: ConcentrationRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).manageConcentrationApiGameCharacterCharacterIdConcentrationPost(characterId, concentrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Equip/unequip items with stat effects.
     * @summary Manage Equipment
     * @param {string} characterId 
     * @param {ManageEquipmentRequest} manageEquipmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public manageEquipmentApiGameCharacterCharacterIdEquipmentPost(characterId: string, manageEquipmentRequest: ManageEquipmentRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).manageEquipmentApiGameCharacterCharacterIdEquipmentPost(characterId, manageEquipmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Apply magical item effects to character stats.
     * @summary Manage Magical Effects
     * @param {MagicalEffectsRequest} magicalEffectsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public manageMagicalEffectsApiGameItemsMagicalEffectsPost(magicalEffectsRequest: MagicalEffectsRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).manageMagicalEffectsApiGameItemsMagicalEffectsPost(magicalEffectsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manage spell slot usage and recovery for a character.
     * @summary Manage Spell Slots
     * @param {string} characterId 
     * @param {ManageSpellSlotsRequest} manageSpellSlotsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public manageSpellSlotsApiGameCharacterCharacterIdSpellSlotsPost(characterId: string, manageSpellSlotsRequest: ManageSpellSlotsRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).manageSpellSlotsApiGameCharacterCharacterIdSpellSlotsPost(characterId, manageSpellSlotsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process a single combat turn.
     * @summary Process Combat Turn
     * @param {string} combatId 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public processCombatTurnApiGameCombatCombatIdTurnPost(combatId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).processCombatTurnApiGameCombatCombatIdTurnPost(combatId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process a player action within a game session.
     * @summary Process Player Action
     * @param {string} sessionId 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public processPlayerActionApiGameSessionSessionIdActionPost(sessionId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).processPlayerActionApiGameSessionSessionIdActionPost(sessionId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process player input and get game response.
     * @summary Process Player Input
     * @param {PlayerInput} playerInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public processPlayerInputApiGameInputPost(playerInput: PlayerInput, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).processPlayerInputApiGameInputPost(playerInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Roll dice using D&D notation.
     * @summary Roll Dice
     * @param {{ [key: string]: string | null; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public rollDiceApiGameDiceRollPost(requestBody: { [key: string]: string | null; }, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).rollDiceApiGameDiceRollPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Roll dice with character context for skill checks.
     * @summary Roll Dice With Character
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public rollDiceWithCharacterApiGameDiceRollWithCharacterPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).rollDiceWithCharacterApiGameDiceRollWithCharacterPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new game session for a campaign.
     * @summary Start Game Session
     * @param {string} campaignId 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public startGameSessionApiGameCampaignCampaignIdStartSessionPost(campaignId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).startGameSessionApiGameCampaignCampaignIdStartSessionPost(campaignId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing campaign.
     * @summary Update Campaign
     * @param {string} campaignId 
     * @param {CampaignUpdateRequest} campaignUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public updateCampaignApiGameCampaignCampaignIdPut(campaignId: string, campaignUpdateRequest: CampaignUpdateRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).updateCampaignApiGameCampaignCampaignIdPut(campaignId, campaignUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



